---
title: Introduction
---

If you find something important missing in outline, open a issue.

## Outline

- algorithms - space and time
- big $O$ notation
    - lower bound, upper bound, tight bound
    - pseudo polynomial, amortized time complexity
- arrays - sort, search
- linked list
    - Single, double, circular
    - insert, delete, search
- Trees
    - nary
    - complete tree
    - binary
        - traversal - inorder, preorder, postorder, level order
        - insert, delete, search
        - binary heap
        - binary search tree
            - self balancing trees
                - AVL trees, red black trees
- Graphs
    - directed, undirected, weighted, cyclic, acyclic
    - traversal - bfs, dfs
    - check for cycle in graph
    - minimum spanning tree
        - Kruskal Algorithm
        - Prim algorithms (Greedy Algorithms)
        - Brovuka'a Algorithm
    - shortest path between one node and all other nodes
        - djkstra's
        - bellman ford's
    - shortest path between all nodes and all paths
        - floyd warshall
        - Johnson's Algorithm
    - dag - directed acyclic graph
        - topological traversal
    - dfs-tree
    - bfs-tree
    - Connectivity
        - Path between two vertices
        - Bridges in a graph
        - Articulation Points
        - bridges
        - Eulerian Path
    - union find
- Range Queries
    - Segment Tree
    - Binary Index Trees
    - sqrt decomposition
- Strings
    - pattern matching
        - KMP method, rabin karp method
    - trie data structure for dictionaries
- Hashing
    - simple hashing
    - collision on hashing
- Algorithm Techniques
    - Two Pointer
    - Monotonic Stack
    - Sliding Window
    - Greedy Algorithms
        - knapsack
    - Dynamic Programming
        - 0/1 knapsack algorithm
        - coin selection
    - Divide and Conquer
        - binary search
        - merge sort
        - quick sort
    - Bitwise algorithms
- P vs NP
    - P
    - NP
    - NP-Complete
    - NP-Hard

## Algorithm

- Algorithm is series of steps to solve a problem.
- In computer science an algorithm is used to solve problems.

## Why study analysis of algorithms?

- some algorithms are fast some are slow and some are fast.
- to choose which algorithm to use we should have some analytical tools
  these are provided by analysis of algorithms

## what about data structure?

- some algorithms need data to be structured in certain way
  for them to work efficiently. this is what data structures do
- how the data is arranged in memory is defined by data structures

- data structure is
    - data organization and
    - management and
    - storage format
- that is usually chosen for efficient access to data
  
- data structure is a collection of data values and the
  relationship among them and the functions or operations that
  can be applied on the data.

## what about abstract data type

- abstract data type are mathematical model of data types
- so here the functionality is present but not how they are
  implemented
- ADT are present from the view of a user
  and data types from the point of view of who is going to implement it.

## outline for data structures

- data structure
    - linear
        - static
        - dynamic
    - non linear
- simple data structures
    - array
    - linked list
    - stack
    - queue
    - binary tree
    - binary search tree
    - heap
    - hashing
    - graph
    - matrix
- complex or specialized data structures
    - segment tree
    - trie
    - binary indexed tree
    - suffix array and suffix tree
    - avl tree
    - red black tree
    - splay tree
    - b tree
    - k dimensional tree

## p vs np

- [p vs np](p-np.md)
